return(condition)
})
})
return(unlist(conditions, recursive = FALSE))
}
# Call the function with your data frame
conditions <- generate_conditions(new_timestamp_format_data_forecastdemand_vic)
print(conditions)
generate_demand_subsets <- function(dataframe) {
# Create an empty list to store results
vic_demand_list <- list()
# Loop through each hour
for (hour in 0:23) {
# Loop through each minute (0 and 30)
for (minute in c(0, 30)) {
# Define condition for current hour and minute
condition <- dataframe$hour == hour & dataframe$minute == minute
# Subset data based on condition
vic_demand <- dataframe[condition, ]
# Store the result in the list
vic_demand_list[[paste0(hour, "_", minute)]] <- vic_demand
}
}
# Return the list of subsets
return(vic_demand_list)
}
# Call the function with your dataframe
vic_demand_subsets <- generate_demand_subsets(new_timestamp_format_data_demand_vic)
print(vic_demand_subsets[["5_30"]])
generate_subsets <- function(data) {
# Create an empty list to store results
subset_list <- list()
# Loop through each hour
for (hour in 0:23) {
# Loop through each minute (0 and 30)
for (minute in c(0, 30)) {
# Define condition for current hour and minute
condition <- data$hour == hour & data$minute == minute
# Subset data based on condition
subset <- data[condition, ]
# Store the result in the list
subset_list[[paste0(hour, "_", minute)]] <- subset
}
}
# Return the list of subsets
return(subset_list)
}
# Call the function with your dataframe
vic_demand_subsets <- generate_subsets(new_timestamp_format_data_demand_vic)
print(vic_demand_subsets[["5_30"]])
vic_temperature_subsets <- generate_subsets(new_timestamp_format_data_temperature_vic)
head(vic_temperature_subsets[["5_30"]])
# Call the function with the dataframe
vic_forecast_subsets <- generate_subsets(new_timestamp_format_data_forecastdemand_vic)
head(vic_forecast_subsets[["5_30"]])
# sa
sa_forecast_subsets <- generate_subsets(new_timestamp_format_data_forecastdemand_sa)
sa_temperature_subsets <- generate_subsets(new_timestamp_format_data_temperature_sa)
sa_demand_subsets <- generate_subsets(new_timestamp_format_data_demand_sa)
# qld
qld_forecast_subsets <- generate_subsets(new_timestamp_format_data_forecastdemand_qld)
# qld
qld_forecast_subsets <- generate_subsets(new_timestamp_format_data_forecastdemand_qld)
qld_temperature_subsets <- generate_subsets(new_timestamp_format_data_temperature_qld)
qld_demand_subsets <- generate_subsets(new_timestamp_format_data_demand_qld)
# nsw
nsw_forecast_subsets <- generate_subsets(new_timestamp_format_data_forecastdemand_nsw)
nsw_temperature_subsets <- generate_subsets(new_timestamp_format_data_temperature_nsw)
nsw_demand_subsets <- generate_subsets(new_timestamp_format_data_demand_nsw)
nrows(vic_demand_subsets[["5_30"]])
vic_demand_subsets[["5_30"]]
vic_temperature_subsets[["5_30"]]
?inner_join
vic_demand_5_30 <- vic_demand_subsets[["5_30"]]
vic_temperature_5_30 <- vic_temperature_subsets[["5_30"]]
inner_join(x = vic_temperature_5_30, y = vic_demand_5_30), by = c(vic_temperature_5_30$DATETIME = vic_demand_5_30$DATETIME))
inner_join(x = vic_temperature_5_30, y = vic_demand_5_30, by = c(vic_temperature_5_30$DATETIME = vic_demand_5_30$DATETIME))
inner_join(x = vic_temperature_5_30, y = vic_demand_5_30, by = c(vic_temperature_5_30$DATETIME, vic_demand_5_30$DATETIME))
vic_demand_5_30 <- vic_demand_subsets[["5_30"]]
vic_demand_5_30$DATETIME <- as.character(vic_demand_5_30$DATETIME)
vic_temperature_5_30 <- vic_temperature_subsets[["5_30"]]
vic_temperature_5_30$DATETIME <- as.character(vic_temperature_5_30$DATETIME)
inner_join(x = vic_temperature_5_30, y = vic_demand_5_30, by = c(vic_temperature_5_30$DATETIME, vic_demand_5_30$DATETIME))
q()
install.packages("readr")
install.packages("here")
install.packages("ggplot2")
install.packages("tidyverse")
install.packages("lubridate")
install.packages("mgcv")
library(readr)
library(here)
library(ggplot2)
library(tidyverse)
library(tidyverse)
library(lubridate)
library(mgcv)
library(fpp2)
install.packages("fpp2")
library(fpp2)
library(fable)
install.packages("fable")
library(fable)
library(feasts)
# VIC
data_forecastdemand_vic <- read_csv(unzip("../data/Australia/a.zip", files = "a/forecastdemand_vic.csv", exdir = tempdir())[1])
data_temperature_vic <- read_csv(unzip("../data/Australia/d.zip", files = "d/temprature_vic.csv", exdir = tempdir())[1])
data_demand_vic <- read_csv(unzip("../data/Australia/d.zip", files = "d/totaldemand_vic.csv", exdir = tempdir())[1])
# SA
data_forecastdemand_sa <- read_csv(unzip("../data/Australia/b.zip", files = "b/forecastdemand_sa.csv", exdir = tempdir())[1])
data_temperature_sa <- read_csv(unzip("../data/Australia/d.zip", files = "d/temprature_sa.csv", exdir = tempdir())[1])
data_demand_sa <- read_csv(unzip("../data/Australia/d.zip", files = "d/totaldemand_sa.csv", exdir = tempdir())[1])
# QLD
data_forecastdemand_qld <- read_csv(unzip("../data/Australia/c.zip", files = "c/forecastdemand_qld.csv", exdir = tempdir())[1])
data_temperature_qld <- read_csv(unzip("../data/Australia/d.zip", files = "d/temprature_qld.csv", exdir = tempdir())[1])
data_demand_qld <- read_csv(unzip("../data/Australia/d.zip", files = "d/totaldemand_qld.csv", exdir = tempdir())[1])
# NSW
#data_forecastdemand_nsw <- read_csv(here("/Users/josephrobertmelbin/Documents/GitHub/Project2/data/NSW/forecastdemand_nsw.csv"))
data_temperature_nsw <- read_csv(unzip("../data/NSW/temperature_nsw.csv.zip", files = "temperature_nsw.csv", exdir = tempdir())[1])
data_demand_nsw <- read_csv(unzip("../data/NSW/totaldemand_nsw.csv.zip", files = "totaldemand_nsw.csv", exdir = tempdir())[1])
# check for null values
check_for_na <- function(data) {
for (col_index in seq_along(data)) {
has_na <- any(is.na(data[[col_index]]))
cat("Column", col_index, "has NA values:", has_na, "\n")
}
}
# Converts string DATETIME into dttm and creates timestamp columns
wrangle_demand_data <- function(df) {
if ("DATETIME" %in% names(df)) {
df <- df %>%
mutate(DATETIME = dmy_hm(`DATETIME`, tz='AUstralia/Brisbane'),
Year = year(DATETIME),        # Extract year
Month = month(DATETIME),      # Extract month
Day = day(DATETIME),          # Extract day
Hour = hour(DATETIME),        # Extract hour
Minute = minute(DATETIME)) %>%  # Extract minute
mutate(TimeOfDay = Hour + Minute / 60,   # Time of the day (0 - 24)
WeekOfMonth = factor(week(DATETIME) - week(floor_date(DATETIME, "month")) + 1, levels = c(1,2,3,4,5,6)),
DayOfWeek = factor(wday(DATETIME, label=TRUE), levels = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")))
} else {
warning("DATETIME column not found in the dataframe.")
}
return(df)
}
df_demand_nsw <- wrangle_demand_data(data_demand_nsw)
df_temperature_nsw <- wrangle_demand_data(data_temperature_nsw)
head(de_demand_nsw)
head(df_demand_nsw)
head(df_temperature_nsw)
df_demand_nsw %>%
ggplot(aes(x=DATETIME, y=TOTALDEMAND)) +
geom_line() +
geom_vline(data = data.frame(x = seq(from = floor_date(min(df_demand_nsw$DATETIME), "year"),
to = ceiling_date(max(df_demand_nsw$DATETIME), "year"),
by = "1 year")),
aes(xintercept = as.numeric(x)),
linetype = "dotted", color = "red") +
scale_x_datetime(
date_breaks = '1 year',
date_labels = '%Y'
) +
theme_minimal()
df_demand_nsw_monthly <- df_demand_nsw %>%
group_by(Month, WeekOfMonth, TimeOfDay) %>%
summarise(MeanDemand = mean(TOTALDEMAND)) %>%
ungroup()
df_demand_nsw_monthly <- df_demand_nsw %>%
group_by(Month, WeekOfMonth, TimeOfDay) %>%
summarise(MeanDemand = mean(TOTALDEMAND)) %>%
ungroup()
df_demand_nsw_monthly %>%
ggplot(aes(x = TimeOfDay, y = MeanDemand)) +
geom_line(aes(color = WeekOfMonth)) +
facet_wrap(~ Month, ncol = 3) +
scale_x_continuous(name = "Time of Day", breaks = seq(0, 24, by = 3), labels = function(x) sprintf("%02d:00", x)) +
scale_y_continuous(name = "Mean Total Demand") +
labs(title = "Weekly Pattern of Electricity Demand by Month") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
strip.text.x = element_text(size = 8))
df_demand_nsw_seasonly <- df_demand_nsw %>%
mutate(Season = case_when(
Month %in% c(12, 1, 2) ~ "Summer",
Month %in% c(3, 4, 5) ~ "Autumn",
Month %in% c(6, 7, 8) ~ "Winter",
Month %in% c(9, 10, 11) ~ "Spring",
TRUE ~ NA_character_))
df_demand_nsw_seasonly %>%
ggplot(aes(x = factor(Hour), y = TOTALDEMAND)) +
geom_boxplot(aes(fill=Season)) +
facet_wrap(~Season, scales = "free_y") + # Faceting by season
labs(title = "Electricity Demand by Hour Across Seasons",
x = "Hour of Day",
y = "Total Demand") +
scale_x_discrete(name = "Time of Day", breaks = seq(0, 24, by = 2)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 1)) # Improve readability of x axis labels
df_demand_nsw_weekly <- df_demand_nsw %>%
group_by(DayOfWeek, TimeOfDay) %>%
summarise(MeanDemand = mean(TOTALDEMAND, na.rm = TRUE))
df_demand_nsw_weekly %>% ggplot(aes(x = TimeOfDay, y = MeanDemand)) +
geom_line(aes(color = DayOfWeek)) +
scale_x_continuous(name = "Time of Day", breaks = seq(0, 24, by = 1), labels = function(x) sprintf("%02d:00", x)) +
scale_y_continuous(name = "Mean Total Demand") +
scale_color_brewer(palette = "Dark2") +
labs(title = "Mean Total Demand by Time of Day and Day of Week") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
df_demand_nsw_daily <- df_demand_nsw %>%
group_by(Month, Day) %>%
summarise(Avg_daily_demand = mean(TOTALDEMAND)) %>%
mutate(DATE = make_date(year=2012, month=Month, day=Day),
MonthName = month(DATE, label=TRUE))
df_demand_nsw_daily %>%
ggplot(aes(x = DATE, y = Avg_daily_demand)) +
geom_line() + # Draw lines between points
geom_point() + # Add points for each data point
geom_smooth() +
scale_x_date(date_breaks = "1 month", date_labels = "%b") + # Customize x-axis labels
labs(x = "Month", y = "Avg demand", title = "Average daily demand") +
theme_minimal() # Use a minimal theme
df_temperature_nsw %>%
ggplot(aes(x=DATETIME, y=TEMPERATURE)) +
geom_line() +
geom_vline(data = data.frame(x = seq(from = floor_date(min(df_temperature_nsw$DATETIME), "year"),
to = ceiling_date(max(df_temperature_nsw$DATETIME), "year"),
by = "1 year")),
aes(xintercept = as.numeric(x)),
linetype = "dotted", color = "red") +
scale_x_datetime(
date_breaks = '1 year',
date_labels = '%Y'
) +
theme_minimal()
install.packages("readr")
install.packages("here")
install.packages("ggplot2")
install.packages("tidyverse")
install.packages("lubridate")
install.packages("mgcv")
install.packages("fpp2")
# Load Data
# Adjusting the paths according to the Github structure:
# VIC
data_forecastdemand_vic <- read_csv(unzip("../data/Australia/a.zip", files = "a/forecastdemand_vic.csv", exdir = tempdir())[1])
library(readr)
library(here)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(mgcv)
library(fpp2)
library(fable)
library(feasts)
# Load Data
# Adjusting the paths according to the Github structure:
# VIC
data_forecastdemand_vic <- read_csv(unzip("../data/Australia/a.zip", files = "a/forecastdemand_vic.csv", exdir = tempdir())[1])
data_temperature_vic <- read_csv(unzip("../data/Australia/d.zip", files = "d/temprature_vic.csv", exdir = tempdir())[1])
data_demand_vic <- read_csv(unzip("../data/Australia/d.zip", files = "d/totaldemand_vic.csv", exdir = tempdir())[1])
# SA
data_forecastdemand_sa <- read_csv(unzip("../data/Australia/b.zip", files = "b/forecastdemand_sa.csv", exdir = tempdir())[1])
data_temperature_sa <- read_csv(unzip("../data/Australia/d.zip", files = "d/temprature_sa.csv", exdir = tempdir())[1])
data_demand_sa <- read_csv(unzip("../data/Australia/d.zip", files = "d/totaldemand_sa.csv", exdir = tempdir())[1])
# QLD
data_forecastdemand_qld <- read_csv(unzip("../data/Australia/c.zip", files = "c/forecastdemand_qld.csv", exdir = tempdir())[1])
data_temperature_qld <- read_csv(unzip("../data/Australia/d.zip", files = "d/temprature_qld.csv", exdir = tempdir())[1])
data_demand_qld <- read_csv(unzip("../data/Australia/d.zip", files = "d/totaldemand_qld.csv", exdir = tempdir())[1])
# NSW
data_temperature_nsw <- read_csv(unzip("../data/NSW/temperature_nsw.csv.zip", files = "temperature_nsw.csv", exdir = tempdir())[1])
data_demand_nsw <- read_csv(unzip("../data/NSW/totaldemand_nsw.csv.zip", files = "totaldemand_nsw.csv", exdir = tempdir())[1])
data_forecastdemand_nsw_part1 <- read_csv(unzip("../data/NSW/forecastdemand/forecastdemand_part1.csv.zip", files = "forecastdemand_part1.csv", exdir = tempdir())[1])
data_forecastdemand_nsw_part2 <- read_csv(unzip("../data/NSW/forecastdemand/forecastdemand_part2.csv.zip", files = "forecastdemand_part2.csv", exdir = tempdir())[1])
data_forecastdemand_nsw_part3 <- read_csv(unzip("../data/NSW/forecastdemand/forecastdemand_part3.csv.zip", files = "forecastdemand_part3.csv", exdir = tempdir())[1])
data_forecastdemand_nsw_part4 <- read_csv(unzip("../data/NSW/forecastdemand/forecastdemand_part4.csv.zip", files = "forecastdemand_part4.csv", exdir = tempdir())[1])
data_forecastdemand_nsw_part5 <- read_csv(unzip("../data/NSW/forecastdemand/forecastdemand_part5.csv.zip", files = "forecastdemand_part5.csv", exdir = tempdir())[1])
# Combine all forecastdemand into 1 df
data_forecastdemand_nsw <- bind_rows(data_forecastdemand_nsw_part1,
data_forecastdemand_nsw_part2,
data_forecastdemand_nsw_part3,
data_forecastdemand_nsw_part4,
data_forecastdemand_nsw_part5)
# Clear memory
rm(data_forecastdemand_nsw_part1,
data_forecastdemand_nsw_part2,
data_forecastdemand_nsw_part3,
data_forecastdemand_nsw_part4,
data_forecastdemand_nsw_part5)
# Converts string DATETIME into dttm and creates timestamp columns
wrangle_demand_data <- function(df) {
if ("DATETIME" %in% names(df)) {
df <- df %>%
mutate(DATETIME = dmy_hm(`DATETIME`, tz='AUstralia/Brisbane'),
Year = year(DATETIME),        # Extract year
Month = month(DATETIME),      # Extract month
Day = day(DATETIME),          # Extract day
Hour = hour(DATETIME),        # Extract hour
Minute = minute(DATETIME)) %>%  # Extract minute
mutate(TimeOfDay = Hour + Minute / 60,   # Time of the day (0 - 24)
WeekOfMonth = factor(week(DATETIME) - week(floor_date(DATETIME, "month")) + 1, levels = c(1,2,3,4,5,6)),
DayOfWeek = factor(wday(DATETIME, label=TRUE), levels = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")))
} else {
warning("DATETIME column not found in the dataframe.")
}
return(df)
}
df_demand_nsw <- wrangle_demand_data(data_demand_nsw)
df_temperature_nsw <- wrangle_demand_data(data_temperature_nsw)
head(df_demand_nsw)
head(df_temperature_nsw)
df_demand_nsw %>%
ggplot(aes(x=DATETIME, y=TOTALDEMAND)) +
geom_line() +
geom_vline(data = data.frame(x = seq(from = floor_date(min(df_demand_nsw$DATETIME), "year"),
to = ceiling_date(max(df_demand_nsw$DATETIME), "year"),
by = "1 year")),
aes(xintercept = as.numeric(x)),
linetype = "dotted", color = "red") +
scale_x_datetime(
date_breaks = '1 year',
date_labels = '%Y'
) +
theme_minimal()
df_demand_nsw_monthly <- df_demand_nsw %>%
group_by(Month, WeekOfMonth, TimeOfDay) %>%
summarise(MeanDemand = mean(TOTALDEMAND)) %>%
ungroup()
df_demand_nsw_monthly %>%
ggplot(aes(x = TimeOfDay, y = MeanDemand)) +
geom_line(aes(color = WeekOfMonth)) +
facet_wrap(~ Month, ncol = 3) +
scale_x_continuous(name = "Time of Day", breaks = seq(0, 24, by = 3), labels = function(x) sprintf("%02d:00", x)) +
scale_y_continuous(name = "Mean Total Demand") +
labs(title = "Weekly Pattern of Electricity Demand by Month") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
strip.text.x = element_text(size = 8))
df_demand_nsw_seasonly <- df_demand_nsw %>%
mutate(Season = case_when(
Month %in% c(12, 1, 2) ~ "Summer",
Month %in% c(3, 4, 5) ~ "Autumn",
Month %in% c(6, 7, 8) ~ "Winter",
Month %in% c(9, 10, 11) ~ "Spring",
TRUE ~ NA_character_))
df_demand_nsw_seasonly %>%
ggplot(aes(x = factor(Hour), y = TOTALDEMAND)) +
geom_boxplot(aes(fill=Season)) +
facet_wrap(~Season, scales = "free_y") + # Faceting by season
labs(title = "Electricity Demand by Hour Across Seasons",
x = "Hour of Day",
y = "Total Demand") +
scale_x_discrete(name = "Time of Day", breaks = seq(0, 24, by = 2)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 1)) # Improve readability of x axis labels
df_demand_nsw_weekly <- df_demand_nsw %>%
group_by(DayOfWeek, TimeOfDay) %>%
summarise(MeanDemand = mean(TOTALDEMAND, na.rm = TRUE))
df_demand_nsw_weekly %>% ggplot(aes(x = TimeOfDay, y = MeanDemand)) +
geom_line(aes(color = DayOfWeek)) +
scale_x_continuous(name = "Time of Day", breaks = seq(0, 24, by = 1), labels = function(x) sprintf("%02d:00", x)) +
scale_y_continuous(name = "Mean Total Demand") +
scale_color_brewer(palette = "Dark2") +
labs(title = "Mean Total Demand by Time of Day and Day of Week") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
df_demand_nsw_daily <- df_demand_nsw %>%
group_by(Month, Day) %>%
summarise(Avg_daily_demand = mean(TOTALDEMAND)) %>%
mutate(DATE = make_date(year=2012, month=Month, day=Day),
MonthName = month(DATE, label=TRUE))
df_demand_nsw_daily %>%
ggplot(aes(x = DATE, y = Avg_daily_demand)) +
geom_line() + # Draw lines between points
geom_point() + # Add points for each data point
geom_smooth() +
scale_x_date(date_breaks = "1 month", date_labels = "%b") + # Customize x-axis labels
labs(x = "Month", y = "Avg demand", title = "Average daily demand") +
theme_minimal() # Use a minimal theme
df_temperature_nsw %>%
ggplot(aes(x=DATETIME, y=TEMPERATURE)) +
geom_line() +
geom_vline(data = data.frame(x = seq(from = floor_date(min(df_temperature_nsw$DATETIME), "year"),
to = ceiling_date(max(df_temperature_nsw$DATETIME), "year"),
by = "1 year")),
aes(xintercept = as.numeric(x)),
linetype = "dotted", color = "red") +
scale_x_datetime(
date_breaks = '1 year',
date_labels = '%Y'
) +
theme_minimal()
## Reference: https://www.michaelplazzer.com/datasets/australian-public-holiday-data/
holidays <- read_csv('../data/Aus_public_hols_2009-2022-1.csv')
holidays_nsw <- holidays %>%
filter(State == 'NSW')
df_demand_nsw_holidays <- df_demand_nsw %>%
mutate(Date = date(DATETIME)) %>%
mutate(
IsHoliday = case_when(
date(DATETIME) %in% holidays_nsw$Date ~ 'Holiday',
TRUE ~ 'Non-Holiday'
))
# Boxplot to compare electricity demand on holidays vs non-holidays
df_demand_nsw_holidays %>%
ggplot(aes(x = IsHoliday, y = TOTALDEMAND)) +
geom_boxplot(aes(fill=IsHoliday)) +
labs(title = "Electricity Demand on Holidays vs. Non-Holidays",
x = "", y = "Total Demand") +
theme_minimal()
df_nsw <- inner_join(df_demand_nsw, df_temperature_nsw, by='DATETIME')
head(df_nsw)
# Note: Loess regression takes long time to run, gam is faster
df_nsw %>%
ggplot(aes(x=TEMPERATURE, y=TOTALDEMAND)) +
geom_point() +
geom_smooth(method = 'gam', color = "blue") + # Adds a gam regression line
labs(title = "Relationship between Temperature and Electricity Demand",
x = "Temperature",
y = "Electricity Demand")
# Converts to daily data to match solar exposure data frequency
df_nsw_daily <- df_nsw %>%
mutate(DATE = as.Date(DATETIME)) %>%
group_by(DATE) %>%
summarise(Daily_Avg_Temperature = mean(TEMPERATURE, na.rm = TRUE),
Daily_Sum_Demand = sum(TOTALDEMAND, na.rm = TRUE))
df_nsw_daily <- inner_join(df_nsw_daily, df_solar_expo_nsw, by = 'DATE')
dfts_demand_nsw <- as_tsibble(df_demand_nsw %>% select(DATETIME, TOTALDEMAND), index=DATETIME)
dfts_demand_nsw %>%
model(STL(TOTALDEMAND ~ season(window = "periodic"))) %>%
components() %>%
autoplot()
# Assuming your data is in a vector called 'electricity_demand'
# Convert your data into a msts object
electricity_demand_ts <- msts(df_demand_nsw$TOTALDEMAND,
seasonal.periods = c(48, 48*7, 48*365.25/12, 48*365.25))
# Fit a TBATS model
fit <- tbats(electricity_demand_ts)
electricity_demand_ts <- ts(df_demand_nsw$TOTALDEMAND, frequency = 48)
decomposed <- stl(electricity_demand_ts, s.window = "periodic")
plot(decomposed)
electricity_demand_ts <- msts(df_demand_nsw$TOTALDEMAND, seasonal.periods = c(48, 48*7, 48*30.44, 48*365.25))
# Perform STL decomposition
stl_decomp <- stl(electricity_demand_ts, s.window="periodic", robust=TRUE)
# Plot the components
plot(stl_decomp)
seasonal_component <- stl_decomp$time.series[, "seasonal"]
head(seasonal_component)
head(df_temperature_nsw)
unique(df_temperature_nsw$Minute)
View(df_temperature_nsw)
unique(df_demand_nsw$Minute)
tolerance <- 1 # minutes
df_temperature_nsw$not_30_min = abs(as.numeric(df$interval) - 30) > tolerance
tolerance <- 1 # minutes
df_temperature_nsw$not_30_min = abs(as.numeric(df_temperature_nsw$Minute) - 30) > tolerance
sum_not_30_min <- sum(df$not_30_min, na.rm = TRUE)
tolerance <- 1 # minutes
df_temperature_nsw$not_30_min = abs(as.numeric(df_temperature_nsw$Minute) - 30) > tolerance
sum_not_30_min <- sum(df_temperature_nsw$not_30_min, na.rm = TRUE)
print(sum_not_30_min)
df_temperature_nsw <- df_temperature_nsw %>%
mutate(out_of_line = !((interval == 0) | (interval == 30)))
df_temperature_nsw <- df_temperature_nsw %>%
mutate(out_of_line = !((Minute == 0) | (Minute == 30)))
# Count how many intervals are out of the expected line
sum_out_of_line <- sum(df_temperature_nsw$out_of_line, na.rm = TRUE)
# Print the count of out-of-line intervals
print(sum_out_of_line)
df_demand
df_demand_nsw
cor_matrix <- cor(df_demand_nsw %>% select(-TOTALDEMAND,-REGIONID,-DATETIME))
colnames(df_demand_nsw)
# Assuming DATETIME is not used for correlation and your data is already in a suitable numeric format
df_demand_nsw <- df_demand_nsw %>% select(-DATETIME, -REGIONID)
cor_matrix <- cor(df_demand_nsw)
df_demand_nsw <- wrangle_demand_data(data_demand_nsw)
df_temperature_nsw <- wrangle_demand_data(data_temperature_nsw)
head(df_demand_nsw)
head(df_temperature_nsw)
# Assuming DATETIME is not used for correlation and your data is already in a suitable numeric format
cor <- df_demand_nsw %>% select(-DATETIME, -REGIONID)
cor_matrix <- cor(df_demand_nsw)
# Assuming DATETIME is not used for correlation and your data is already in a suitable numeric format
cor <- df_demand_nsw %>% select(-DATETIME, -REGIONID) %>% mutate(across(everything(), as.numeric))
cor_matrix <- cor(df_demand_nsw)
cor
# Assuming DATETIME is not used for correlation and your data is already in a suitable numeric format
cor <- df_demand_nsw %>% select(-DATETIME, -REGIONID) %>% mutate(across(everything(), as.numeric))
cor_matrix <- cor(cor)
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45, # Text label color and rotation for readability
addCoef.col = "black") # Add correlation coefficients to the plot for clarity
library(readr)
library(here)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(mgcv)
library(fpp2)
library(fable)
library(feasts)
library(corrplot)
install.packages("readr")
install.packages("here")
install.packages("ggplot2")
install.packages("tidyverse")
install.packages("lubridate")
install.packages("mgcv")
install.packages("fpp2")
install.packages("fable")
install.packages("corrplot")
